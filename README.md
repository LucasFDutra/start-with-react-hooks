[**English**](#English)
[**Português**](#Português)

# English
---
# What this repository is about
I will describe what each hook is for and I will create a simple project to exemplify each one. I will do this in order to study.

[Link to documentation](https://pt-br.reactjs.org/docs/hooks-intro.html)

# What to install
- [NodeJS](https://nodejs.org/en/)
- [yarn - optional](https://yarnpkg.com/)

# What are hooks
Hooks allow the application to connect to the states and life cycles of the react, from functional components. In a simpler way, this means that hooks interact with our application dynamically, controlling variables or actions.

# Common to all projects
For all projectos you will need to type:

```sh
$ yarn create react-app PROJECT_NAME
```

Where `PROJECT_NAME` is located, you must change it to the name of the project in question

To  start the projects, enter the folder through the terminal and use the command:

```sh
$ yarn start
```

All projects will be simple, and without stylization. Having the sole purpose of studying hooks. Soon, some files generated by `create react-app` will be deleted. Are they:

```sh
PROJECT_NAME/src/App.css
PROJECT_NAME/src/App.test.js
PROJECT_NAME/src/index.css
PROJECT_NAME/src/logo.svg
PROJECT_NAME/src/setupTests.js
PROJECT_NAME/src/serviceWorker.js
PROJECT_NAME/README.md
```

The file `App.js` will be have the following initial code:

```JavaScript
import React from 'react';

function App() {
  return (
    <div>
      Olá mundo
    </div>
  );
}

export default App;
```

And the file `index.js` will be:

```JavaScript
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);
```

Every react hook is imported as follows:

```JavaScript
import {hookName} from 'react';
```

Of course, since react should always be imported too, we will always have:

```JavaScript
import React, {hookName} from 'react';
```

# use-state

## Usefulness of the hook
useState is used to save a state. In a simple way, it sabes the value of a variable and can also change it.

## How to use

```JavaScript
const [variable, setVariable] = useState(initialValue);
```

That is, useState return an array with the value of the variable and a function to control it and also defines an initial value for that variable.

If you want to modify the value of `variable` just use the function `setVariable` as follows:

```JavaScript
setVariable(NEW_VALUE);
```

The cool thing about this is that whenever the value is changed, react will render the DOM automatically

## The project
Inside the `App.js` file we will write a simple project, which will have a button that when clicked will change the value of the variable returned by the hook. This value will appear in a text just above the button

```JavaScript
import React, {useState} from 'react';

function App() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)} >Add +1</button>
    </div>
  );
}

export default App;
```

<img src='./images/figure001.gif' width='200' />


# use-effect
## Usefulness of the hook
It's an effect hook. Whenever something predetermined happens in the application it will execute.

This hook can perform two diferent functions.

## How to use

#### When assembling the component
```JavaScript
useEffect(() => {
  code...
}, []);
```

With this syntax it executes the code as soon as the component is assembled.

#### When updating the component

```JavaScript
useEffect(() => {
  code..
}, [watchman]);
```

With this syntax it will execute as soon as the `watchman` variable is modified, causing the `code` to be executed.

## The Project
I will build an application inside `App.js` that will show some `console.log` just to be able to understand how it works.

```JavaScript
import React, {useState, useEffect} from 'react';

function App() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('montagem do componente');
  }, []);
  
  useEffect(() => {
    console.log('atualização do componente');
  }, [count]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)} >Add +1</button>
    </div>
  );
}

export default App;

```

<img src='./images/figure002.gif' width='400' />

See that at the beginning it also shows the component update, but this is becouse as soon as the component is generated the value of `count` is assigned, so this is a change in the variable, so it executes.

# use-context

## Usefulness of the hook
For when we want a component tree to have access to certain properties. In other words, with this we avoid passing `props` on the components. A very good thing is that if the context value is changed, all the places involved by it will be rendered again.

> However, it is worth mentioning that this solution applies only to components within the same component tree. And that one should be careful with that, as it can harm the reuse of components.

## How to use
To indicate its use, I will take the exeample of the react documentation itself.

```JavaScript
// creates an object to be our contex
const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee"
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222"
  }
};

// creates the context used in a default object
const ThemeContext = React.createContext(themes.light);

// main app involved in the context provider
function App() {
  return (
    <ThemeContext.Provider value={themes.dark}>
      { /* chama um componente filho */ }
      <Toolbar />
    </ThemeContext.Provider>
  );
}

function Toolbar(props) {
  return (
    <div>
      { /* calls a third component level */ }
      <ThemedButton />
    </div>
  );
}

function ThemedButton() {
  // uses the hook to invoke the context created there at the first level
  const theme = useContext(ThemeContext);
  return (
    <button style={{ background: theme.background, color: theme.foreground }}>
      I am styled by theme context!
    </button>
  );
}
```

`themes.light` is not the value that will reach `ThemedButton`, the value taht will reach there is `themes.dark`. However, if `ThemedButton` requires something that does not correspond to what was passed as an attribute in the provider, then the default value is used (if it corresponds to it).

## The Project
Here i will do the same thing as the documentation example, but in a cooler way, and showing the automatic reload functionality between components that participate in the provider.

For this I create two button components, both with very similar codes, sharing the same context, but one of them has the function of modifying the context values. As soon as the values are modified, the other button also reloads with the new values.

> NOTE 1.: Even if the second component did not use useContext it would reload, this is because it enters the provider.

> NOTE 2.: See that if we put the provider involving our entire App, the entire application will reload whenever something changes. Se be careful with that.

- Defining the initial theme in `Themes.js`
```JavaScript
export default {
    light: {
        foreground: "#000000",
        background: "#eeeeee"
    },
    dark: {
        foreground: "white",
        background: "black"
    }
};
```

- Creating a null context in `Context.js`
```JavaScript
import React from 'react';
  
const ThemeContext = React.createContext(null);

export default ThemeContext;
```

- Placing the context provider within the `App.js`
```JavaScript
import React, {useState} from 'react';
import Button from './Button';
import Button2 from './Button2';
import ThemeContext from './Context'
import themes from './Themes';

function App() {
  const [theme, setTheme] = useState(themes);

  return (
    <ThemeContext.Provider value={{theme, setTheme}}>
      <Button />
      <Button2 />
    </ThemeContext.Provider>
  );
}

export default App;
```

> Note that the value forwarded was the variable and function of useState, which will allow us to execute setTheme on the components below and thus propagate this change throughout the component tree.

- Creating the change button in `Button.js`
```JavaScript
import React, {useContext} from 'react';
import ThemeContext from './Context'

const Button = (props) => {
    const theme = useContext(ThemeContext);
    const newTheme = {
        light: {
            foreground: "#000000",
            background: "#eeeeee"
        },
        dark: {
            foreground: "#ff79c6",
            background: "#282a36"
        }
    };

    return (
        <button style={{ background: theme.theme.dark.background, color: theme.theme.dark.foreground }} onClick={() => theme.setTheme(newTheme)}>
            Primeiro Botão
        </button>
    );
}

export default Button;
```

- Creating the other button that only serves to show the functionality in `Button2.js`
```JavaScript
import React, {useContext} from 'react';
import ThemeContext from './Context'

const Button2 = (props) => {
    const theme = useContext(ThemeContext);
    console.log('aqui');
    
    return (
        <button style={{ background: theme.theme.dark.background, color: theme.theme.dark.foreground }}>
            Segundo botão
        </button>
    );
}

export default Button2;
```

<img src='./images/figure003.gif' width='300' />

# use-reducer
## Usefulness of the hook
It works as an alternative to useState, it serves to store states. And it becomes preferale to useState when there is a logic of complex states happening within the component.

If you've heard of redux, this will seem like a lot, but it turns out that useReducer is more recommended for working within a component, and redux for managing the state of the entire application. Of course, if we use useReducer in conjunction with useContext we will have something very close to redux, but it all depends on how you will implement this.

## How to use

```JavaScript
import React, {useReducer} from 'react';

const initialState = {/* object with initial values */}

const reducer = (state, action) => {
  switch (action.type) {
    case 'instrução_passada_pela_action':
      return {/* state change */};
  }
};

function App() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return(
    // jsx code
  )
}

export default App;
```

Use the `dispatch` function to be able to modify the state value according to some action.

```JavaScript
() => dispatch({type: 'instrução'})
```

## The Project
I will make a simple counter using the hook.

```JavaScript
import React, {useReducer} from 'react';

const initialState = {count: 0}

const reducer = (state, action) => {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    default:
      throw new Error();
  }
};

function App() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return(
    <>
      Count: {state.count}
      <div>
        <button onClick={() => dispatch({type: 'decrement'})}>-</button>
        <button onClick={() => dispatch({type: 'increment'})}>+</button>
      </div>
    </>
  )
}

export default App;
```

<img src='./images/figure004.gif' width='300' />

# use-callback
## Usefulness of the hook
When a function is created in memory it occupies a space, and in that it gains a reference. And the compartmentalization between functions is done exactly by comparing the reference, that is, if the two functions pointer points to the same address, they are logically equal. However, with each render of the react the function is recreated, which makes the reference change.

Loking at it through the optics of an example (which will be our project).

Suppose a parent component and inside a child component, that child component receives a function through the `props`, and whenever what is rendered it also needs to be rendered. So far everything is normal, but you notice that you don't need to render the child again, so put it around a `memo`, which will prevent the child from rendering again when the current `props` are the same as the previous ones. However he continues to render always.

This is becouse the function that is passad by `props` is not inside a `useCallback`, so whenever the parent component reloads the function it changes the reference and `memo` thinks that the prop has changed. But if we put this function inside `useCallback` it will verify that no attributes of the function have been modified, so it does not need to reconstruct the function, and this prevents the function reference from being modified and thus `memo` takes the equality of the prop and avoids the render of the cild.

In short, `useCallback` avoids recreating a function unnecessarily.

## How to use

```JavaScript
const memorizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);
```

Now instead of calling `doSmething` you call `momorizedCallback`. That is, the use callback returns a function that performs the same thing as the function inside it, however this new function may or may not have another reference depending on whether the parameter inside the brackets have been modified.

- [Recommendation](https://www.youtube.com/watch?v=RZG0iRfUaY0)

## The Project
I will create a counter, but divided into two files, one being the button component that will not render again every time. But I also need to use the memo.

- Button
  ```JavaScript
  import React, {memo} from 'react';

  const Button = memo(({increment}) => {
    console.log('render');
    return(
      <div>
        <button onClick={() => increment()}>Add + 1</button>
      </div>
    );
  }
  )

  export default Button;
  ```

- App
  ```JavaScript
  import React, {useState, useCallback} from 'react';
  import Button from './Button';

  function App() {
    const [count, setCount] = useState(0);
    
    const increment = useCallback(() => {
      setCount(value => value + 1);
    }, []);

    return (
      <div>
        <p>Count: {count}</p>
        <Button increment={increment} />
      </div>
    );
  }

  export default App;
  ```
<img src='./images/figure005.gif' width='300' />

See that the render appears only once and then you don't need it anymore. Because the function hasn't changed, so what arrives at the `Button` hasn't changed either. If I passed the `setCount` directly to the `Button` component, it would render again even with the `memo`.

# use-memo
## Usefulness of the hook
It works identically to `useCallback`, but it does not return a function with the same reference, it returns the value returned by the function and prevents it from being executed again if it is unnecessary.

## How to use

```JavaScript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

## The Project
Again we're gaing to do an accountant. But this time we'll also show you the longest word among two words in an array.

```JavaScript
import React, { useState, useMemo } from "react";

function computeLongestWord(data) {
  console.log('verificando palavras');
  if (data[0].lenght > data[1].lenght){
    return data[0];
  } else {
    return data[1];
  }
}

const data = ['palavra', 'outra palavra']

const App = () => {
  const [count, setCount] = useState(0);

  const longestWord = useMemo(() => computeLongestWord(data), [data]);

  return (
    <div>
      <div>count: {count}</div>
      <button onClick={() => setCount(count + 1)}>increment</button>
      <div>{longestWord}</div>
    </div>
  );
};

export default App;
```

<img src='./images/figure006.gif' width='300' />

Note that the `computeLongestWord` function is not executed every time we add a new value to the counter, which generates a new render. However, as use memo saw that `data` hasn't changed anything since the last render, it didn't changed anything since the last render, it didn't trigger the `computeLongestWord` function.

This would not happend if the `data` had been declared within the app, as the `data` would always be recreated, and this would make the memo use believe that there was a change.

# use-ref
## Usefulness of the hook
It serves to define references to things in our component, whether this is a function or a component within the component. And then we can retrieve that reference somewhere else.

## How to use

```JavaScript
const refContainer = useRef(initialValue);
```

## The Project
Here we are going to reference a component of our component, and we are going to perform a modification on it without calling it directly, we are going to call it by its reference. This action will simply focus on the input after clicking the button.

```JavaScript
import React, {useRef} from 'react';

function App() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus no input</button>
    </>
  );
}

export default App;

```

<img src='./images/figure007.gif' width='300' />

# use-imperative-handle
## Usefulness of the hook
Used in conjunction with `useRef`, this hook allows a method from within a component to be executed by another.

## How to use

```JavaScript
useImperativeHandle(ref, createHandle, [deps])
```

## The Project
In this project I will create a component that has a button that performs the increment in value, and another button within the app that performs the increment fuction within the other button.

```JavaScript
import React, {useState, forwardRef, useImperativeHandle, useRef} from 'react';

const ComponentWithButton = forwardRef((props, ref) => {
  useImperativeHandle(ref, () => ({increment}))
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);
  return (
    <div>
      <button onClick={increment}>click</button>
      <h2>Count: {count}</h2>
    </div>
  )
})


const App = () => {
  const ref = useRef();
  return (
    <div>
      <ComponentWithButton ref={ref} />
      <button onClick={() => ref.current.increment()}>another button</button>
    </div>
  );
};

export default App;
```

<img src='./images/figure008.gif' width='300' />

# use-layout-effect
## Usefulness of the hook
It works just like `useEffect` but it doesn't run at the start of loading the component, it runs after everything is rendered. It can be useful to capture dimensions of the screen after operations are done that can for example modify the size of a phase, and to style that part according to this new size.

## How to use

```JavaScript
useLayoutEffect(() => {
  code...
}, []);
```

# Português
---

# Do que se trata esse repositório
Vou descrever para que serve cada hook e criarei um projeto simples para exemplificar cada um. Farei isso com o objetivo de estudar.

[Link para a documentação](https://pt-br.reactjs.org/docs/hooks-intro.html)

# O que instalar
- [NodeJS](https://nodejs.org/en/)
- [yarn - opcional](https://yarnpkg.com/)

# O que são os hooks
Os hooks permitem que a aplicação se ligue aos estados e ciclos de vida do react, a partir de componentes funcionais.
De uma forma mais simples, isso quer dizer que os hooks interagem com nossa aplicação de forma dinâmica, controlando variáveis ou ações.

# Comum a todos os projetos
Para todos os projetos será necessário digitar 
```sh
$ yarn create react-app NOME_DO_PROJETO
```

Sendo que onde está `NOME_DO_PROJETO` você deve trocar pelo nome do projeto em questão

Para inicializar os projetos, entre na pasta do mesmo pelo terminal e utilize o comando 
```sh
$ yarn start
```

Todos os projetos serão simples, e sem estilizações. Tendo a finalidade exclusiva de estudar os hooks. Logo alguns arquivos gerados pelo `create react-app` serão apagados. São eles:

```sh
NOME_DO_PROJETO/src/App.css
NOME_DO_PROJETO/src/App.test.js
NOME_DO_PROJETO/src/index.css
NOME_DO_PROJETO/src/logo.svg
NOME_DO_PROJETO/src/setupTests.js
NOME_DO_PROJETO/src/serviceWorker.js
NOME_DO_PROJETO/README.md
```
O arquivo `App.js` ficará com o seguinte código inicial

```JavaScript
import React from 'react';

function App() {
  return (
    <div>
      Olá mundo
    </div>
  );
}

export default App;
```

E o arquivo `index.js` ficará:

```JavaScript
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);
```

Todo hook do react é importado da seguinte forma

```JavaScript
import {nomeDoHook} from 'react';
```

Claro que como o react sempre deve ser importado também, teremos sempre:

```JavaScript
import React, {nomeDoHook} from 'react';
```

# use-state

## Utilidade do hook
O useState serve para guardar um estado. De forma simples, ele guarda o valor de uma váriavel e também pode alterá-la.

## Como utilizar

```JavaScript
const [variable, setVariable] = useState(initialValue);
```

Ou seja, o useState retorna um array com o valor da variável e uma função para controlá-la e também define um valor inicial para essa variável.

Caso queira modificar o valor de `variable` basta usar a função `setVariable` da seguinte forma:

```JavaScript
setVariable(NOVO_VALOR);
```

O legal disso é que sempre que o valor for alterado o react irá renderizar novamente a DOM automaticamente.

## O projeto
Dentro do arquivo App.js vamos escrever um projeto simples, que terá um botão que quando clicado irá mudar o valor da variável retornada pelo hook. Esse valor irá aparecer em um texto logo acima do botão

```JavaScript
import React, {useState} from 'react';

function App() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)} >Add +1</button>
    </div>
  );
}

export default App;
```

<img src='./images/figure001.gif' width='200' />


# use-effect
## Utilidade do hook
É um hook de efeito. Sempre que algo pré-determinado acontecer na aplicação ele irá executar

Esse hook consegue exercer duas funções diferentes (que me interessam kkk)

## Como utilizar

#### Na montagem do componente
```JavaScript
useEffect(() => {
  código...
}, []);
```

Com essa sintaxe ele executa o código assim que o componente é montado.

#### Na atualização do componente

```JavaScript
useEffect(() => {
  código
}, [vigia]);
```

Com essa sintaxe ele executará assim que a variável `vigia` for modificada, fazendo com que o `código` será executado.

## O projeto
Vou construir uma aplicação dentro do `App.js` que mostrará alguns `console.log` somente para poder compreendermos como funciona

```JavaScript
import React, {useState, useEffect} from 'react';

function App() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('montagem do componente');
  }, []);
  
  useEffect(() => {
    console.log('atualização do componente');
  }, [count]);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)} >Add +1</button>
    </div>
  );
}

export default App;

```

<img src='./images/figure002.gif' width='400' />

Veja que no inicio ele também mostra a atualização do componente, mas isso é porque assim que o componente é gerado o valor de `count` é atribuído, logo isso é uma mudança na variável, por isso ele executa.



# use-context

## Utilidade do hook
Para quando queremos que uma árvore de componentes tenha acesso a determinadas propriedades. Ou seja, com isso evitamos de ficar passando `props` nos componentes. Uma coisa muito boa, é que caso o valor do contexto seja alterado todos os lugares envolvidos por ele serão renderizados novamente.

> Porém vale ressaltar que essa solução se aplica apenas para componentes dentro da mesma árvore de componentes. E que se deve ter um certo cuidade com isso, pois pode prejudicar a reutilização de componentes.

## Como utilizar
Para indicar sua utilização, vou pegar o exemplo da propria documentação do react.

```JavaScript
// cria um objeto para ser nosso contexto
const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee"
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222"
  }
};

// cria o contexto utilizadno um objeto default
const ThemeContext = React.createContext(themes.light);

// app principal envolvido no provider do contexto
function App() {
  return (
    <ThemeContext.Provider value={themes.dark}>
      { /* chama um componente filho */ }
      <Toolbar />
    </ThemeContext.Provider>
  );
}

function Toolbar(props) {
  return (
    <div>
      { /* chama um terceiro nível de componente */ }
      <ThemedButton />
    </div>
  );
}

function ThemedButton() {
  // usa o hook para invocar o contexto criado lá no primeiro nível
  const theme = useContext(ThemeContext);
  return (
    <button style={{ background: theme.background, color: theme.foreground }}>
      I am styled by theme context!
    </button>
  );
}
```

`themes.light` não é o valor que chegará ao `ThemedButton`, o valor que chegará lá é o `themes.dark`. Porém caso o `ThemedButton` requera algo que não corresponda ao que foi passado como atributo no provider então o valor defaul é utilizado (caso tenha correspondencia com ele).

## O projeto
Aqui farei a mesma coisa que o exemplo da documentação, porém de um jeito mais legal, e mostrando a funcionalidade de reload automatico entre componentes que participam do provider.

Para isso eu criei dois componentes de botão, ambos com códigos muito parecidos, compartilhando o mesmo contexto, porém um deles possui a função de modificar os valores do contexto. Assim que os valores são modificados o outro botão também recarrega com os novos valores.

> OBS 1.: mesmo que o segundo componente não utilizasse o useContext ele iria recarregar, isso porque ele entá dentro do provider.

> OBS 2.: Veja que se colocarmos o provider envolvendo todo o nosso App a aplicação inteira irá recarregar sempre que algo for alterado. Logo tome cuidado com isso.

- Definindo o tema inicial em `Themes.js`
```JavaScript
export default {
    light: {
        foreground: "#000000",
        background: "#eeeeee"
    },
    dark: {
        foreground: "white",
        background: "black"
    }
};
```

- Criando um contexto nulo em `Context.js`
```JavaScript
import React from 'react';
  
const ThemeContext = React.createContext(null);

export default ThemeContext;
```

- Colocando o provider do contexto dentro do `App.js`
```JavaScript
import React, {useState} from 'react';
import Button from './Button';
import Button2 from './Button2';
import ThemeContext from './Context'
import themes from './Themes';

function App() {
  const [theme, setTheme] = useState(themes);

  return (
    <ThemeContext.Provider value={{theme, setTheme}}>
      <Button />
      <Button2 />
    </ThemeContext.Provider>
  );
}

export default App;
```

> Veja que o valor encaminhado para frente foi a variável e a função do useState, o que nos permitirá executar o setTheme nos componentes abaixo e assim propagar essa mudança por toda a árvore de componentes

- Criando o botão de modificação em `Button.js`
```JavaScript
import React, {useContext} from 'react';
import ThemeContext from './Context'

const Button = (props) => {
    const theme = useContext(ThemeContext);
    const newTheme = {
        light: {
            foreground: "#000000",
            background: "#eeeeee"
        },
        dark: {
            foreground: "#ff79c6",
            background: "#282a36"
        }
    };

    return (
        <button style={{ background: theme.theme.dark.background, color: theme.theme.dark.foreground }} onClick={() => theme.setTheme(newTheme)}>
            Primeiro Botão
        </button>
    );
}

export default Button;
```

- Criando o outro botão que serve somente para mostrar a funcionalidade em `Button2.js`
```JavaScript
import React, {useContext} from 'react';
import ThemeContext from './Context'

const Button2 = (props) => {
    const theme = useContext(ThemeContext);
    console.log('aqui');
    
    return (
        <button style={{ background: theme.theme.dark.background, color: theme.theme.dark.foreground }}>
            Segundo botão
        </button>
    );
}

export default Button2;
```

<img src='./images/figure003.gif' width='300' />

# use-reducer
## Utilidade do hook
Ele funciona de alternativa ao useState, ele serve para guardar estados. E se torna preferível ao useState quando se tem uma lógica de estados complexas acontecendo dentro do componente.

Se já ouviu falar de redux, isso aqui vai parecer bastante, mas acontece que o useReducer é mais recomendado para trabalhar dentro de um componente, e o redux para gerenciar os estados de toda a aplicação. Claro que se utilizarmos o useReducer em conjunto com o useContext teremos uma coisa bem proxima ao redux, mas tudo depende do como você irá implementar isso.

## Como utilizar

```JavaScript
import React, {useReducer} from 'react';

const initialState = {/*objeto com os valores iniciais*/}

const reducer = (state, action) => {
  switch (action.type) {
    case 'instrução_passada_pela_action':
      return {/*modificação no state*/};
  }
};

function App() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return(
    // codigo jsx
  )
}

export default App;
```

Utilize a função `dispatch` para poder modificar o valor do state de acordo com alguma action.

```JavaScript
() => dispatch({type: 'instrução'})
```

## O projeto
Vou fazer um contador simples utilizando o hook.

```JavaScript
import React, {useReducer} from 'react';

const initialState = {count: 0}

const reducer = (state, action) => {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    default:
      throw new Error();
  }
};

function App() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return(
    <>
      Count: {state.count}
      <div>
        <button onClick={() => dispatch({type: 'decrement'})}>-</button>
        <button onClick={() => dispatch({type: 'increment'})}>+</button>
      </div>
    </>
  )
}

export default App;
```

<img src='./images/figure004.gif' width='300' />

# use-callback
## Utilidade do hook
Quando uma função é criada na memoria ela ocupa um espaço, e nisso ela ganha uma referênica. E o compartivo entre funções é feito exatamente comparando a referência, ou seja, se o ponteiro de duas funções apontarem para o mesmo endereço elas são logicamente iguais. Porém, a cada render do react a função é recreada, o que faz a referencia mudar.

Olhando isso na pela óptica de um exemplo (que será o nosso projeto).

Suponha um componente pai e dentro um componente filho, esse componente filho recebe uma função por meio das `props`, e sempre o que renderiza ele tb precisa ser renderizado. Até ai tudo normal, mas você nota que não precisa renderizar novamente o filho sempre, então coloca em torno de um `memo`, que irá impedir o filho de renderizar novamente quando as `props` atuais forem iguais as anteriores. Porém ele continua renderizando sempre.

Isso acontece pois a função que é passada por `props` não está dentro de um `useCallback`, logo sempre que o componente pai recarregar a função modifica a referência e o `memo` pensa que a prop mudou. Mas se colocarmos essa função dentro do `useCallback` ele verificará que nenhum atributo da função foi modificado, logo ele não precisa reconstruir a função, e isso impede que a referência da função seja modificada e assim o `memo` pega a igualdade da prop e evita o render do filho.

Em resumo, o `useCallback` evita recrear uma função de forma desnecessária.

## Como utilizar

```JavaScript
const memorizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);
```

Agora ao em vez de chamar por `doSomething` você chama por `memorizedCallback`. Ou seja, o use callback retorna uma função que executa a mesma coisa que a função dentro dele, porém essa nova função pode ou não ter outra referência dependendo se os parâmetros dentro de colchetes foram modificados.

- [Recomendação](https://www.youtube.com/watch?v=RZG0iRfUaY0)

## O projeto
Criarei um contador, mas dividido em dois arquivos, sendo um o componente botão que não irá renderizar novamente toda vez. Mas também preciso usar o `memo`.

- Button
  ```JavaScript
  import React, {memo} from 'react';

  const Button = memo(({increment}) => {
    console.log('render');
    return(
      <div>
        <button onClick={() => increment()}>Add + 1</button>
      </div>
    );
  }
  )

  export default Button;
  ```

- App
  ```JavaScript
  import React, {useState, useCallback} from 'react';
  import Button from './Button';

  function App() {
    const [count, setCount] = useState(0);
    
    const increment = useCallback(() => {
      setCount(value => value + 1);
    }, []);

    return (
      <div>
        <p>Count: {count}</p>
        <Button increment={increment} />
      </div>
    );
  }

  export default App;
  ```
<img src='./images/figure005.gif' width='300' />

Veja que o render aparece uma unica vez e depois não precisa mais. Pq a função não mudou, logo o que chega no Button também não mudou. Se eu passasse direto o setCount pro componente Button, ele iria renderizar novamente mesmo com o memo.

# use-memo
## Utilidade do hook
Funciona de forma identica ao useCallback, porém ele não retorna uma função com mesma referência, ele retorna o valor retornado por aquela função e evita que ela seja executada novamente caso seja desnecessário.

## Como utilizar

```JavaScript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

## O projeto
Novamente vamos fazer um contador. Mas dessa vez também mostraremos qual a maior palavra dentre duas palavras de um array.

```JavaScript
import React, { useState, useMemo } from "react";

function computeLongestWord(data) {
  console.log('verificando palavras');
  if (data[0].lenght > data[1].lenght){
    return data[0];
  } else {
    return data[1];
  }
}

const data = ['palavra', 'outra palavra']

const App = () => {
  const [count, setCount] = useState(0);

  const longestWord = useMemo(() => computeLongestWord(data), [data]);

  return (
    <div>
      <div>count: {count}</div>
      <button onClick={() => setCount(count + 1)}>increment</button>
      <div>{longestWord}</div>
    </div>
  );
};

export default App;
```

<img src='./images/figure006.gif' width='300' />

Veja que a função `computeLongestWord` não é executada toda vez que adicionamos um novo valor ao contador, o que gera um novo render. Porém como o use memo viu que `data` não mudou nada desde o ultimo render, ele não disparou a função `computeLongestWord`.

Isso não aconteceria se o `data` tivesse sido declarado dentro da app, pois o `data` seria recriado sempre, e isso faria com que o use memo acreditasse que houve mudança.

# use-ref
## Utilidade do hook
Ele serve para definir referências para coisas do nosso componente, sendo isso uma função ou então um conponente dentro do componente. E depois podemos resgatar essa referência em algum outro lugar.

## Como utilizar

```JavaScript
const refContainer = useRef(initialValue);
```

## O projeto
Aqui vamos referenciar um componente do nosso componente, e vamos executar uma modificação nele sem chamá-lo diretamente, vamos chamá-lo pela sua referência. Essa ação será simplesmente dar o foco ao input após clicar no botão.

```JavaScript
import React, {useRef} from 'react';

function App() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus no input</button>
    </>
  );
}

export default App;

```

<img src='./images/figure007.gif' width='300' />

# use-imperative-handle
## Utilidade do hook
utilizado juntamente com o useRef, esse hook permite que um método de dentro de um componente seja executado por outro.

## Como utilizar

para utilizar:
```JavaScript
useImperativeHandle(ref, createHandle, [deps])
```

## O projeto
nesse projeto vou criar um componente que tem um botão que executa o incremento em valor, e outro botão dentro do app que executa a função de incremento dentro do outro botão.

```JavaScript
import React, {useState, forwardRef, useImperativeHandle, useRef} from 'react';

const ComponentWithButton = forwardRef((props, ref) => {
  useImperativeHandle(ref, () => ({increment}))
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);
  return (
    <div>
      <button onClick={increment}>click</button>
      <h2>Count: {count}</h2>
    </div>
  )
})


const App = () => {
  const ref = useRef();
  return (
    <div>
      <ComponentWithButton ref={ref} />
      <button onClick={() => ref.current.increment()}>another button</button>
    </div>
  );
};

export default App;
```

<img src='./images/figure008.gif' width='300' />

# use-layout-effect
## Utilidade do hook
Ele funciona igual ao useEffect porém ele não executa no inicio do carregamento do componente, ele executa depois de tudo ser renderizado. Pode ser útil para capturar dimensões da tela após operaçoes serem feitas que podem por exemplo modificarem o tamanho de uma fase, e estilizar aquela parte de acordo com esse novo tamanho.

## Como utilizar

```JavaScript
useLayoutEffect(() => {
  código...
}, []);
```
